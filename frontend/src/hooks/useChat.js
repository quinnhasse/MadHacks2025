import { useState, useCallback } from 'react';
import { NODE_TYPES, NODE_STATES, SAMPLE_CONVERSATIONS } from '../utils/constants';

export function useChat() {
  const [conversations, setConversations] = useState(SAMPLE_CONVERSATIONS);
  const [activeConversation, setActiveConversation] = useState(null);
  const [messages, setMessages] = useState([]);
  const [nodes, setNodes] = useState([
    {
      id: 'answer-core',
      type: NODE_TYPES.ANSWER_CORE,
      label: 'Answer Core',
      position: { x: 0, y: 0, z: 0 },
      state: NODE_STATES.IDLE,
      content: '',
    },
  ]);
  const [isLoading, setIsLoading] = useState(false);
  const [showAnswer, setShowAnswer] = useState(false);
  const [currentAnswer, setCurrentAnswer] = useState(null);

  const sendMessage = useCallback(async (content) => {
    const userMessage = {
      id: Date.now().toString(),
      role: 'user',
      content,
      timestamp: new Date().toISOString(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setShowAnswer(false);

    // Update answer core to thinking state
    setNodes((prev) =>
      prev.map((node) =>
        node.id === 'answer-core'
          ? { ...node, state: NODE_STATES.THINKING, label: 'Thinking...' }
          : node
      )
    );

    try {
      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 1500));

      // Generate thinking nodes around the core
      const thinkingNodes = [
        {
          id: 'thinking-1',
          type: NODE_TYPES.GENERATING,
          label: 'Analyzing Context',
          position: { x: 2, y: 1, z: 0 },
          state: NODE_STATES.ACTIVE,
          tier: 'primary',
        },
        {
          id: 'thinking-2',
          type: NODE_TYPES.GENERATING,
          label: 'Retrieving Sources',
          position: { x: -2, y: 1, z: 0 },
          state: NODE_STATES.ACTIVE,
          tier: 'secondary',
        },
        {
          id: 'thinking-3',
          type: NODE_TYPES.GENERATING,
          label: 'Generating Response',
          position: { x: 0, y: -2, z: 1.5 },
          state: NODE_STATES.ACTIVE,
          tier: 'secondary',
        },
        {
          id: 'source-1',
          type: NODE_TYPES.SOURCE,
          label: 'Wikipedia',
          position: { x: 3, y: 0, z: -1 },
          state: NODE_STATES.COMPLETE,
          tier: 'tertiary',
        },
        {
          id: 'source-2',
          type: NODE_TYPES.SOURCE,
          label: 'Research Paper',
          position: { x: -3, y: -1, z: 1 },
          state: NODE_STATES.COMPLETE,
          tier: 'tertiary',
        },
      ];

      setNodes((prev) => [
        ...prev.map((node) =>
          node.id === 'answer-core'
            ? { ...node, state: NODE_STATES.ACTIVE, label: 'Answer Core' }
            : node
        ),
        ...thinkingNodes,
      ]);

      // Simulate answer generation
      await new Promise((resolve) => setTimeout(resolve, 2000));

      const assistantMessage = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: `This is a comprehensive answer to your question: "${content}".

The answer involves multiple aspects and has been synthesized from various sources. Let me break it down for you:

1. **Primary Analysis**: The core concept relates to fundamental principles that govern the subject matter.

2. **Supporting Evidence**: Based on retrieved sources, we can see multiple perspectives that inform our understanding.

3. **Practical Applications**: This knowledge can be applied in real-world scenarios to solve concrete problems.

4. **Further Exploration**: There are several related topics worth investigating to deepen your understanding.

This response has been generated by analyzing contextual information and synthesizing it into a coherent explanation.`,
        timestamp: new Date().toISOString(),
        sources: [
          { id: 'source-1', name: 'Wikipedia', url: '#' },
          { id: 'source-2', name: 'Research Paper', url: '#' },
        ],
      };

      setMessages((prev) => [...prev, assistantMessage]);
      setCurrentAnswer(assistantMessage);
      setShowAnswer(true);

      // Mark all nodes as complete
      setNodes((prev) =>
        prev.map((node) => ({ ...node, state: NODE_STATES.COMPLETE }))
      );
    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const createNewConversation = useCallback(() => {
    const newConv = {
      id: Date.now().toString(),
      title: 'New Conversation',
      timestamp: new Date().toISOString(),
    };
    setConversations((prev) => [newConv, ...prev]);
    setActiveConversation(newConv.id);
    setMessages([]);
    setNodes([
      {
        id: 'answer-core',
        type: NODE_TYPES.ANSWER_CORE,
        label: 'Answer Core',
        position: { x: 0, y: 0, z: 0 },
        state: NODE_STATES.IDLE,
        content: '',
      },
    ]);
    setShowAnswer(false);
    setCurrentAnswer(null);
  }, []);

  const selectConversation = useCallback((id) => {
    setActiveConversation(id);
    // In a real app, you would load the conversation's messages and nodes
  }, []);

  const resetNodes = useCallback(() => {
    setNodes([
      {
        id: 'answer-core',
        type: NODE_TYPES.ANSWER_CORE,
        label: 'Answer Core',
        position: { x: 0, y: 0, z: 0 },
        state: NODE_STATES.IDLE,
        content: '',
      },
    ]);
  }, []);

  return {
    conversations,
    activeConversation,
    messages,
    nodes,
    isLoading,
    showAnswer,
    currentAnswer,
    sendMessage,
    createNewConversation,
    selectConversation,
    resetNodes,
  };
}
